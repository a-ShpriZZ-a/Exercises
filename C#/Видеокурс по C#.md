# Видеокурс по C#

## Лекция 1 — Логические операторы

Операторы первого ранга (выполняются в первую очередь):

- `x.y` - оператор доступа к методу класса;

- `x?.y` - оператор проверки на `null`, то есть:
  если `x == null`, то выражение вернёт `null`;

- `a[i]` - получение элемента по индексу;

- `x?[y]` - оператор проверки массива на `null`, то есть:
  если массив не определён, выражение вернёт `null`;

- `f(x)` - оператор вызова функции;

- `x++` `x--` - операторы инкремента и декремента (постфиксный оператор).
  Операторы являются постфиксными, то есть изменяют значение после своего использование. Например:

  ```C#
  int x = 5;
  Console.WriteLine(x++);
  
  // Консоль выведет 5, так как x увеличит своё значение после того как выполнение Console.Writeline будет завершено.
  ```

- `new` - создание экземпляра объекта;

- `typeof(x)` - возвращает тип переданного объекта; 

- `checked` - оператор проверки на переполнение. Например:

  ```C#
  byte x = 255;
  x = checked((byte)(x + 10));
  
  // Будет вызвано исключение System.OverflowException, так как произойдёт переполнение типа byte.
  ```

- `unchecked` - оператор, избегающий проверки переполнения (используется по-умолчанию);

- `default` - устанавливает начальное значение переменной.

  ```C#
  int x = default; // x = 0
  ```

- `nameof(x)` - вернёт имя переменной `x`;

- `delegate` - создание анонимного метода;

- `sizeof(x)` - вернёт количество занимаемой памяти типом `x`;

- `stackalloc` - выделение блока памяти в стеке;

- `x -> y` - разыменовывание указателя;

Операторы второго ранга (унарные операторы):

- `+x` - унарный плюс;

- `-x` - унарный минус;

- `!x` - изменяет значение `bool` на противоположное;

- `~x` - оператор инвертирующий биты. Пример:

  ```C#
  byte x = 30;       // 00011110 = 30
  byte y = (byte)~x; // 11100001 = 225
  
  // В C# байтовые значения задаются с помощью 0b - 0b0001110
  ```

- `++x` `--x` - операторы аналогичные  `x++` и `x--`, но сперва увеличивают значение, а потом выполняют действие.

- `^x` - оператор позволяет брать брать элементы с конца массива. Пример:

  ```c#
  int[] nums = {0, 1, 2, 3, 4};
  
  Console.WriteLine(nums.length() - 1); // 4
  Console.WriteLine(nums[^1]);          // 4
  
  // Отсчёт элементов с конца считается с 1. 
  // ^0 вызовет исключение.
  ```

- `(T)x` - приводит операнд ` x` к типу `T`;

- `await` - оператор для асинхронного программирования.

- `&x` - адресный оператор ссылочной переменной `x`;

- `*x` - оператор определения указателя;

- `true`/`false` - абсолютная истина/ложь; Позволяет переопределить `true` и `false` внутри класса.

 Операторы третьего ранга:

- `x..y` - позволяет задать интервал.

Операторы четвертого ранга (мультипликативные):

- `x*y` - умножение;
- `x/y` - деление;
- `x%y` - остаток от деления.

Операторы пятого ранга:

- `x+y` - сумма;
- `x-y` - разность.

Операторы шестого ранга (используется для умножения на два):

- `x << y` - побитовый сдвиг влево;
- `x >> y` - побитовый сдвиг вправо;

```C#
// Используется для умножения и деления числа на два.

int x = 12;
x = x << 1; // Так же можно "x <<= 1".

Console.WriteLine(x); // 24
```

Операторы седьмого ранга:

- `x < y` - меньше;
- `x > y` - больше;
- `x <= y` - меньше либо равно;
- `x >= y` - больше либо равно;
- `x is y` - если операнд `x` соответствует типу `y`, вернут `true`, иначе `false`; 
- `x as y` - приводит операнд `x` к типу `y`. Если приведение невозможно, возвращает `null`.

Операторы восьмого ранга:

- `x == y` - тут и объяснять нечего;
- `x != y` - тоже нечего объяснять.

Девятый ранг: `x & y` - логическое «И»;

Десятый ранг: `x ^ y` - исключающее «ИЛИ»;

Одиннадцатый ранг: `x | y` - логическое «ИЛИ»;

Двенадцатый ранг: `x && y` - оператор «И»;

Тринадцатый ранг: `x || y` - оператор «ИЛИ»;

Четырнадцатый ранг: `x ?? y` - проверка типов. Пример:

```C#
string x = "hello";
string a = x ?? "null";
Console.WriteLine(a); // Выведет "hello", так как x не null.

string x = null;
string a = x ?? "null";
Console.WriteLine(a); // Выведет "null", так как x null.
```

Пятнадцатый ранг: `c ? t : f` - тернарный оператор. Пример:

```C#
int x = 10;
int y = x < 15 ? "Холодно!" : "Тепло!";
Console.WriteLine(y); // Выведет «Холодно», так как x < 15.

int x = 20;
int y = x < 15 ? "Холодно!" : "Тепло!";
Console.WriteLine(y); // Выведет «Тепло», так как x > 15.
```

Шестнадцатый ранг - операторы присваивания: `x = y`, `x += y`, `x ^= y`, `x <<= y` и оператор декларации лямбда-счисления - `=>`.

## Лекция 2 — Методы

### Локальные функции

Локальные функции - функции внутри метода.
Локальные функции можно использовать для создания **рекурсивных методов** *(очень удобно!!!)* или функций, которые вызываются только в одном методе, для которых создание отдельной функций внутри класса нецелесообразно.
Локальная функция может использовать переменные определенные внутри старшего метода.

```C#
void F(string text)
{
    bool check(int num)
    {
        if (text[num] == 'c') return true;
        else return false;
    }
    
    check(3);
}
```

### Статичные функции

Статичные функции используется для вызова определенного метода без создания отдельного её экземпляра.
Статичные функции могут создаваться для процедур, создание отдельного экземпляра класса которым нецелесообразно.
Например вывод текста в консоль или обработка какого-то числа.

### Расширение

Расширения используются для добавления определённого нового функционала в определенный класс.

```C#
// Класс обазательно должен быть static, как и методы в нём.
static class StringExtension
{
    // К параметру обязательно добавлять слово «this».
    // Благодаря ему, программа поймёт, что в строке
    // bool res = "Dude".IsDude();
    // «"Dude"» является передаваемым параметром.
    public static bool IsDude(this string text)
    {
        if (text == "Dude") return true;
        if (text != "Dude") return false;
    }
}
```

После определения расширения и при условии, что пространство имён нового класса находится в области видимости, его можно будет вызвать.

```C#
string x = "Not Dude";
bool result = x.IsDude();
Console.WriteLine(result); // false

string x = "Dude";
bool result = x.IsDude();
Console.WriteLine(result); // true
```

### Перегрузка методов

Если внутри класса определить несколько методов с разными принимаемыми аргументами, но одним именем, то программа будет сама выбирать тот метод, которому подходят переданные аргументы.

```C#
int Sum(int a, int b) { return a + b; }
double Sum(double a, double b) { return a + b; }
```

```C#
int a = Sum(3, 4);
Console.WriteLine(a); // 7

double a = Sum(3.3, 4.3);
Console.WriteLine(a); // 7.6
```

Но если перегружаемые методы полностью идентичны по содержанию, можно переписать следующим образом:

```C#
static void Swap<T>(ref T objOne, ref T objTwo)
{
    T temp = objOne;
    objOne = objTwo;
    objTwo = temp;
}
```

```c#
int x = 3;
int y = 4;
Swap(ref x, ref y);
Console.WriteLine(x); // 4
Console.WriteLine(y); // 3

int x = "i'm x";
int y = "i'm y";
Swap(ref x, ref y);
Console.WriteLine(x); // i'm y
Console.WriteLine(y); // i'm x
```