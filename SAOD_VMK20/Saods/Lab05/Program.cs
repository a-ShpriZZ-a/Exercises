// [Взрывоопасность]
// При переработке радиоактивных материалов образуются отходы двух видов — особо опасные (тип A) и неопасные(тип B).
// Для их хранения используются одинаковые контейнеры.
// После помещения отходов в контейнеры, последние укладываются вертикальной стопкой.
// Стопка считается взрывоопасной, если в ней подряд идет более двух контейнеров типа A.
// Для заданного количества контейнеров N определить число безопасных стопок.

// Формат входных данных — Одно число 0 < N < 31.
// Формат выходных данных — Количество безопасных вариантов формирования стопки.

// by ShpriZZ

class Program
{
    // Длинна цепочки.
    static readonly int LENGTH = 4;

    // Список цепочек.
    static readonly List<string> STRINGS = new() { "A", "B" };

    static void Main()
    {
        DynamicAlg(); // Рабочий цикл.
        FileOut();    // Файловый вывод.
        ConsOut();    // Консольный вывод.

        Console.ReadKey();
    }

    // Рабочий ход программы.
    static void DynamicAlg()
    {
        // Если требуемая длина слишком большая или слишком маленькая - выходим.
        if (LENGTH < 1 || LENGTH > 31) return;

        // Цикл выполняется, пока необходимая 
        while (STRINGS[0].Length < LENGTH)
        {
            // Сохраняем текущее кол-во элементов в списке.
            // Это нужно, чтобы избежать зацикливания при добавления новой цепочки в список.
            // Внутри цикла работаем с каждой цепочкой отдельно.
            int sLength = STRINGS.Count;
            for (int i = 0; i < sLength; i++)
            {
                // Получаем стартовый индекс для разбивки строки.
                // Нужно отделить последние два символа от строки.
                int sIndex = STRINGS[i].Length > 2 ? STRINGS[i].Length - 2 : 0;

                // Получаем прогноз следующего символа по двум последним.
                var s = Prognosis(STRINGS[i][sIndex..]);

                // Если в прогнозе несколько возможных символов,
                // добавляем в массив новую строку.
                if (s.Length == 2) STRINGS.Add(STRINGS[i] + s[1]);
                STRINGS[i] += s[0]; // Увеличиваем длину текущей строки.
            }
        }
    }

    // Прогнозирование следующих символов в строке.
    static char[] Prognosis(in string prev)
    {
        // Если в цепочке уже идут два раза "А",
        // то следующим символом может быть только "B".
        // Иначе может быть любой символ.
        if (prev == "AA") return new char[] { 'B' };
        else return new char[] { 'A', 'B' };
    }

    // Консольный вывод.
    static void ConsOut()
    {
        Console.WriteLine($"Длина: {LENGTH} симв.");
        Console.WriteLine($"Безопасных цепочек: {STRINGS.Count}.");
        Console.WriteLine("Список цепочек:");
        for (int i = 0; i < STRINGS.Count; i++)
            Console.WriteLine($"{i+1}. {STRINGS[i]}");
    }

    // Вывод в файл.
    static void FileOut()
    {
        using var sw = new StreamWriter("result.txt");
        sw.WriteLine($"Длина: {LENGTH} симв.");
        sw.WriteLine($"Безопасных цепочек: {STRINGS.Count}.");
        sw.WriteLine("Список цепочек:");
        for (int i = 0; i < STRINGS.Count; i++)
            sw.WriteLine($"{i + 1}. {STRINGS[i]}");
    }
}